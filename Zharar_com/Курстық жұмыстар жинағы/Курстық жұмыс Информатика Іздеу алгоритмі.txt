Мазмұны1.	Кіріспе									2.	Есептің қойылымы							3.	Теориялық мағлұматтар									3.1 Іздеу алгоритмі							 3.1.1 Интерполяциялық іздеу әдісі3.1.2 Сызықты іздеу  әдісі.3.1.4 Қарапайым алгоритм.3.2.1 Сұрыптау тәсілі3.2.2 Сұрыптау алгоритмі3.2.3 Орналастыру әдісі арқылы сұрыптау.3.2.4 Көпіршік тәсілі4 Программаның жазылуыҚорытынды										Қолданылған әдебиеттерІздеу алгоритміБарлық әдістерді статикалық және динамикалық деп қарастыруға болады
Массивтен статикалық әдіспен іздеу кезінде оның мәндері өзгермейді
Массивтен динамикалық әдіспен іздеу кезінде оның өлшемі өзгеруі мүмкін, себебі ол қайтадан сұрыпталады
Біз көбінде статикалық әдісті қолданамыз, үйткені мәтіндік редактордағы сөздерді өзгерте алмаймыз, ал динамикалық тәсіл ойын құрғанда пайдаланылады.Іздеу әдістерін сондай-ақ нақты кілттерді пайдаланатын және туындаушы кілттерді пайдаланатын деп екіге бөледі
Бұл жағдайда кілт деп өзіміз іздеп отырған сөзді айтады
Мәтіндік редакторға қолданылатын кілт – туындаушы болып табылады, себебі ізделінетін массив алдын-ала алфавит бойынша сұрыпталған
Бұл рет іздеуді жеңілдету үшін пайдаланылады.Интерполяциялық іздеу әдісіКейбір кітаптарда бұл әдіс «экстраполяция әдісі» деп аталады
Экстарполяция – берілген интервалдан тыс бірнәрсені анықтау әдісі, ал интерпояция – сол интервал аралығына анықтау әдісі
Сондықтан да «экстраполяция әдісі» деп атау қате, үйткені ізделінетін сөзді шекарадан тыс аумақта іздеу мүмкін емес.бұл әдісті сипаттамас бұрын сізге ағылшын тіліндегі «treasure» сөзінің аудармасы қажет болды дейік
Яғни сіздің алдыңызда тапсырма – осы сөзді сөздіктен іздеу
Біздің келесі іс-әркеттеріміз қандай да бір іздеу алгоритмін құрумен жалғасады
Ізделінетін сөзді алфавит бойынша сұрыпталған массивтен іздейміз, ал керекті сөз бізге белгілі
Енді осы іздеуге толығымен тоқталайық
Бізге керекті сөз «т» әрпінен басталады, яғни алфавиттің екінші бөлігінде, немесе біз ол қандай орында тұрғанында шамамен есептеп ала аламыз
Яғни қанша дым жасауға болатынын анықтап аламыз
Егер ізделінетін массив үлкен болса осы әдіс арқылы оның шекрасын көрсетіп, тек осы аралықты ғана іздеуге болады
Ол үшін келесідей ек теңдік аламыз:T1=M*N;T2=2M*Log(2)N+N*Log(2)N;N – массивтегі элементтердің саны.M – рет іздеуге болады.Тура ауытырудың алгоритмі жасайтын операция саны M*N-ге тең
Ал сұрыптауға кететін уақыт N*Log(2)N-ге тең, оған тағы 2M*Log(2)N дихотомия әдісін қосамыз
T1=T2 кезінде екі алгоритм де тиімді шекарада боламыз
Сызықты іздеу  әдісі.Алдымен linearsearch (сызықты іздеу) деген шағын порграмма құрастырайық
Оның үш параметрі болады: Strings – жолдың өрнектер қптпры, newstring – жолдың өрнек, осыны іздеу қажет және size – қаралатын қатардың элемпенттер саны.Біздің басты программамызда екі тип анықталған және оларды біз linearsearch-ңформальді параметрін баяндауда қолданамыз:Type StrType=String[20]ArrayStrType=Array[1..100] Of StrType;Енді біз шағын прогарамманың басын жаза аламыз:Function linearsearch(Strings:ArrayStrType; NewString:String;Size:Integer):Integer;{……………………………………………………………………….}{Сызықты іздеу әдісін қолдана отырып, String қатарының алғашқы Size элементінен NewString өрнегінің позициясын қайтару керек, ол жоқ болса, 0-ді қайтару керек.................................................................................................................................}String қатарынынң әр элементі NewString – пен салыстырылады
Егер де мәндері сәйкес келсе, онда табылған элементтің  позийиясы (индексі) қайтарылады
Ал егер NewString – ті барлық элементтермен салыстырып болған соң, керекті жолдың өрнек табылмаса, онда 0 мәні қайтарылады, бұл – іздеуден түк шықпады деген сөз
Сипатталған процессте барлық элементтер кезекпен салыстырылады
Сондықтан бұл әдісті сызықты немесе тізбектелген іздеу әдісі деп атайды.әр элемент Strings жодың өрнегінде бір-бірден кездеседі деп ойлайық(егер бұлай болмаса, онда олардың бірінші рет кездескендерін белгілеп отырамыз)
Егер элемент табылса, әрі қарай процесс тоқтатылады, сондықтан логикалық Found айнымалысын енгізейік:Var position:Integer;Found:Boolean;BeginPosition:=1;Found:=False;While (not Found) And (position=size) DoBeginIf Strings [position]=NewString ThenBeginLinearsearch:=position;Found:=True;End; {If…Then}Position:=position+1;End; {While циклінің соңы}If not Found Then linearsearch:=0;End; {linearsearch}Егер сіз көңіл аударсаңыз, While циклі мына екеуінің біреуі орындалмағанша жүре береді: not Found өрнегі жалған болмағанша не position мәні size-дан асып кетпегенше.LinearSearch функциясының қолданылуы.Біздің linearsearch функциямызда басты программада қалай қолдануға болады? Мысалы, n соңды аттардан тұратын қатарда іздеу жүргізу керек болсын, осы мақсатпен басты программада names қатары баяндалған, сонымен қатар ізделінді есімді сақтайтын NewName айнымалысы да баяндалған
Онда LinearSearch функциясын шақыратын программа үзіндісі былай болады:Type StrType=String[20];ArrayStrType=Array[1..100] Of StrType;Var Names:ArrayStrType;NewName:StrType;N,location:Integer;…….Location:=linearsearch(names,n);If location>0Then WriteLn(NewName,’орны’,location)Else WriteLn(newName,’табылған жоқ’)Қарапайым алгоритм.Алгоритмді қарау үшін бір мысалды қарастырайық
Сонымен бізде n символдан тұратын мәтін берілген, оны Т деп атайық немесе T[i] және оның і-ші символы деп атауға да болады
m символдан тұратын жолды немесе сөзді S деп немесе S[i] және оның i-ші символы деп атайық
Бізге берілген жол берілген мәтінде бар ма, бар болса мәтіннің қандай символынан басталатындығын табу керек.Біз m символы мәтіннің жолының қай символдарымен сәйкес келетіндігін тексереміз
Оны іске асыру үшін Паскальда келесі кодты жазамыз:Program SimpleSearch;Var T:array[1..40000] of char;{мәтін ролін анықтайды}S: array[1..10000] of char;	{жолдың ролін атқарады}i, j:longint;m, n:longint;begin {программа денесін баяндау}Қарапайым түрде жаздық, енді осы программаның тиімділігін тәжірибе жүзінде тексеруге болады.Сұрыптау алгоритміСұрыптаудың Шелл әдісі бойынша сұрыптау, Хоар әдісі бойынша сұрыптау, таңдап сұрыптау сияқты түрлері бар.Сұрыптау дегеніміз—берілген жиынның элементтерін белгілі бір ережелерге сәйкес орналастыру
Оның негізгі көздеген мақсаты – сұрыпталған жиыннан керек элементтерді іздеуді жеңілдету
Сұрыптауды көбіне массивтерді және файлдарды сұрыптағанда көп қолданады
Бұл екеуін әдетте ішкі және сыртқы сұрыптаулар деп атайды
Массивтер “ішкі” (жедел) жадыда орналасатындықтан, ішкі сұрыптау болады
Бұл жадыға тез қатынаймыз, ал файлдар бұдан бәсеңдеу, бірақ сыйымдылығы үлкендеу “сыртқы” жадыда, яғни есте сақтау құрылғыларында (диск, лента т.б.)  сақталатындықтан, оны сыртқы сұрыптау деп атаймыз.Іздеу әдістерінің де әдістері бір-бірімен қатты байланысқан
Әсіресе, біз бинарлы әдісті, егер қатарымыз сұрыпталған болса, тинтен қолдана алмаймыз
Мысалы, біз бинарлы іздеу әдісін миллиондаған фамилияларды іздеген кезде қолданамыз
Ал ол кітапшадағы фамилиялар алфавит әріптері бойынша сұрыпталған
Яғни, іздеу бар жерде сұрыптау міндетті түрде болу керек.Тағы сұрыптаудың орналастыру арқылы сұрыптау түрі бар
Бұл әдістің негізгі мәні алдыңғы реттелген элементтерге соңғы элементтерді бір-бірлеп қосып отыруда
Әрине, бұл сұрыптаумен танысқан адам, көп уақытқа созылатын процесс деп ойлауы мүмкін
Бірақ олай емес, өйткені алдыңғы элементтер сұрыпталған күйде болады да, келесі элементті сәйкес кез-келген жерге қоямыз.Орналастыру әдісі арқылы сұрыптау.Бұл әдістің негізгі мәні алдыңғы реттелген элементтерге соңғы элементтерді бір-бірімен қосып отыруда
Бірінші қадамға алғашқы екі элемент сұрыпталады
Содан кейін осы екі элементпен салыстырылып, сәйкес орынға үшінші элемент орналастырылады
Үш сұрыпталған элементтерге төртінші элементті қосамыз
Ол жаңа төрттіктегі өз орнына жайғасады
Сөйтіп, сұрыпталған n-1 элементтерге соңғы n-ші элемент қосылғанша жалғаса береді
Осы әдіске мысал ретінде мына процедураны қарастырайық:Procedure ins(var x:Array Of Integer; n:Integer);Var i,j,t:Integer;BeginFor i:=1 To n-1 DoBeginT:=x[i];J:=i-1;While (j>=0) And (tT[i+1].f3 then 					 {begin 							 el=*t[j];switch:=true; 						 *t[j]=*t[j+1];temp:=T[i]; 						 *t[j+1] = el;T[i]:=T[i+1];						 pr=1;T[i+1]:=temp 						 }end 							 }until not(switch) 					}while(pr==1);end 							 }Бұл тәсіл ауыстыру тәсілімен сұрыптауды пайдаланады
Ол салыстыру операцияларының циклында орындалуында және көршілес тұрған элементтерін ауыстыруға қажеттігіне негізделген